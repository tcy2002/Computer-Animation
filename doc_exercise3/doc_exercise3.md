## 0. 实现效果
请查看demo.mp4或运行程序。由于作业里实现sweep and prune使用了另外的rigidobject列表，因此宽域和窄域必须同时都选或都不选own方法。

## 1. 使用旋转矩阵和四元数更新旋转的区别
- 旋转矩阵更直观，时间步长$\Delta t$内，刚体绕旋转轴$\frac{w}{|w|}$旋转$|w|\cdot \Delta t$弧度，旋转矩阵相乘表示附加旋转；但缺点是数值精度问题，即多次更新后旋转矩阵可能会丧失正交性，需要重新正交化，并且储存空间要求更大。不过一般而言，轻微偏离正交化影响并不大。
- 四元数不太直观，将旋转参数用复空间的向量来表示，但数值精度稳定，旋转矩阵的乘法对应四元数的加法，多次旋转叠加后通过归一化仍能保持单位长度，而且节省储存空间。

## 2. 改进的宽域碰撞
采用sweep and prune方案。每一帧的思路为：
- 首先更新每个刚体的AABB包围盒；
- 选择一个轴向$x/y/z$，按照包围盒对刚体列表进行排序，包围盒下界更小的刚体排在前面；
- 按照常规方法遍历刚体列表，当遍历到后一个刚体在选择的轴向上的包围盒下界大于前一个的包围盒上界时，由于已经按照轴向排好序，说明后面的刚体不可能与上一个刚体发生重叠，停止遍历。
- 选择一个分布最稀疏的轴向作为下一帧的目标轴向。

算法分析和改进点：这种方式的复杂度虽然也是$O(n^2)$，但由于可以提前结束遍历，因此略优于暴力遍历。考虑到相邻帧之间，场景内刚体的变化幅度不大，更合理的方式是不需要每一帧都重新排序，而是根据刚体之间在轴向上的相对位置变化维护其在刚体列表中的顺序，本次作业暂未实现。相比于空间搜索树等其他方案，这种方式在维护和更新空间搜索树上的开销更小，在小场景下的性能并不亚于空间搜索树。

## 3. 改进的窄域碰撞检测
采用SAT方法。思路为：
- 由于算法后续步骤中面求交的需要，必须将三角mesh转化为凸包格式。
- 首先检测刚体$a$和$b$的面的法矢量是否存在分离轴，再检测刚体棱的叉积是否存在分离轴；
- 若找到一条分离轴，说明刚体不可能发生重叠，否则选择重叠距离最小的一条轴向，确定两个刚体相对这条轴“最近”的面，即两个刚体首当其冲发生相互接触的面；
- 使用面面求交算法，得到接触面上的碰撞点。

算法分析和改进点：这种方式的优点是可以达到比较良好的稳定效果，即一个刚体静止在另一个刚体表面时，不会因为碰撞点的计算不稳定而发生抖动。其实这在方式也会存在corner case，最好在检测到棱棱分离轴时直接根据棱棱交点添加碰撞点；而且在某些极端情况下，比如薄片刚体，其实碰撞并不一定发生在“最近”面上，可以通过判断最近点（即supporting vertex）是否在对方内部来避免错误检测。以上改进在科大引擎里做了，本次作业只针对Box和Box的碰撞，一般不会出现上述特殊情况，因此并未实现。

## 4. 基于冲量的碰撞约束：
按照作业文档和参考论文的公式实现即可。
附加考虑摩擦力：步骤基本相同，额外考虑切向即可。根据参考论文，需要对切向冲量按照库伦摩擦定律进行约束：
$$-\mu j_n \leq j_t \leq \mu j_n$$
并且保证冲量方向和发生相对滑动的切向方向相反。具体实现时，考虑到数值精度问题，当切向速度小于一定阈值(比如$1e-5$)时，不进行计算。

## 5. 存在的问题和改进方向
- 除了3中提到的碰撞检测问题外，基于冲量的方法也会存在drift的问题，即刚体会发生重叠，相互侵入，并且当侵入已经发生时，无法很好地恢复，可以使用其他约束方法来避免。
- 另外，当摩擦系数比较大时，也会存在不稳定的问题，暂未确定具体原因，可能也与基于冲量的方法本身有关。